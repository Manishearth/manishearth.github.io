
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Understanding Git Filter-branch and the Git Storage Model - In Pursuit of Laziness</title>
  <meta name="author" content="Manish Goregaokar">

  
  <meta name="description" content="The other day Steve wanted git alchemy done on the Rust repo. Specifically, he wanted the reference and nomicon moved out into
their own repositories &hellip;">
  
  <!-- Tweaked https://harimenon.com/blog/2013/02/23/twitter-cards-for-octopress-blogs/ -->
  
      <meta property="twitter:card" content="summary">
      <meta property="twitter:site" content="Manishearth">
      <meta property="twitter:url" content="http://manishearth.github.io">
      <meta property="twitter:title" content="Understanding git filter-branch and the git storage model">
      <meta property="twitter:description" content="The other day Steve wanted git alchemy done on the Rust repo. Specifically, he wanted the reference and nomicon moved out into
their own repositories, preserving history. Both situations had some &hellip;">
      <meta name="twitter:image" content="http://manishearth.github.io/images/me.png" />
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://manishearth.github.io/blog/2017/03/05/understanding-git-filter-branch/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="In Pursuit of Laziness" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/manish.js" type="text/javascript"></script>
  <!--- MathJax Configuration -->
  
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-62537162-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">In Pursuit of Laziness</a></h1>
  
    <h2>Manish Goregaokar's blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="manishearth.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Understanding Git Filter-branch and the Git Storage Model</h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


<div class="entry-content"><p>The other day <a href="http://twitter.com/steveklabnik">Steve</a> wanted git alchemy done on the Rust repo.</p>

<p>Specifically, he wanted the reference and nomicon moved out into
their <a href="https://github.com/rust-lang-nursery/reference">own</a> <a href="https://github.com/rust-lang-nursery/nomicon">repositories</a>, preserving history. Both situations had some interesting
quirks, the reference has lived in <code class="language-plaintext highlighter-rouge">src/doc/reference/*</code> and <code class="language-plaintext highlighter-rouge">src/doc/reference.md</code>,
and the nomicon has lived in <code class="language-plaintext highlighter-rouge">src/doc/nomicon</code>, <code class="language-plaintext highlighter-rouge">src/doc/tarpl</code>, and at the top level
in a separate git root.</p>

<p>As you can guess from the title of this post, the correct tool for this job is <code class="language-plaintext highlighter-rouge">git filter-branch</code>.
<a href="https://twitter.com/indygreg">My colleague Greg</a> calls it “the swiss-army knife of Git history rewriting”.</p>

<p>I had some fun with filter-branch that day, thought I’d finally write an accessible tutorial for it. A lot
of folks treat filter-branch like rebase, but it isn’t, and this crucial difference can lead to many
false starts. It certainly did for me back when I first learned it.</p>

<p>This kind of ties into the common bit of pedantry about the nature of a commit I keep seeing pop up:</p>

<blockquote>
  <p><a href="https://twitter.com/ManishEarth/status/837203953926352896">Git commits appear to be diffs, but they’re actually file copies, but they’re actually ACTUALLY diffs.</a></p>
</blockquote>

<h2 id="so-what-is-a-git-commit">So what is a git commit?</h2>

<p>Generally we interact with git commits via <code class="language-plaintext highlighter-rouge">git show</code> or by looking at commits on
a git GUI / web UI. Here, we see diffs. It’s natural to think of a commit as a diff,
it’s the model that makes the most sense for the most common ways of interacting
with commits. It also makes some sense from an implementation point of view, diffs
seem like an efficient way of storing things.</p>

<p>It turns out that the “real” model is not this, it’s actually that each commit
is a snapshot of the whole repo state at the time.</p>

<p>But actually, it isn’t, the underlying implementation does make use of deltas
in packfiles and some other tricks like copy-on-write forking.</p>

<p>Ultimately, arguing about the “real” mental model is mostly pedantry. There are
multiple ways of looking at a commit. The documentation tends to implicitly think
of them as “full copies of the entire file tree”, which is where most
of the confusion about <code class="language-plaintext highlighter-rouge">filter-branch</code> comes from. But often it’s important
to picture them as diffs, too.</p>

<p>Understanding the implementation can be helpful, especially when you break the
repository whilst doing crazy things (I do this often). I’ve explained how it works
in a later section, it’s not really a prerequisite for understanding filter-branch,
but it’s interesting.</p>

<h2 id="how-do-i-rewrite-history-with-git-rebase">How do I rewrite history with <code class="language-plaintext highlighter-rouge">git rebase</code>?</h2>

<p>This is where some of the confusion around <code class="language-plaintext highlighter-rouge">filter-branch</code> stems from. Folks have worked with
<code class="language-plaintext highlighter-rouge">rebase</code>, and they think <code class="language-plaintext highlighter-rouge">filter-branch</code> is a generalized version of this. They’re actually quite
different.</p>

<p>For those of you who haven’t worked with <code class="language-plaintext highlighter-rouge">git rebase</code>, it’s a pretty useful way of rewriting
history, and is probably what you should use when you want to rewrite history, especially for
maintaining clean git history in an unmerged under-review branch.</p>

<p>Rebase does a whole bunch of things. Its core task is, given the current branch and a branch that
you want to “rebase onto”, it will take all commits unique to your branch, and apply them in order
to the new one. Here, “apply” means “apply the diff of the commit, attempting to resolve any conflicts”.
At times, it may ask you to manually resolve the conflicts, using the same tooling
you use for conflicts during <code class="language-plaintext highlighter-rouge">git merge</code>.</p>

<p>Rebase is much more powerful than that, though. <code class="language-plaintext highlighter-rouge">git rebase -i</code> will open up “interactive rebase”,
which will show you the commits that are going to be rebased. In this interface, you can reorder
commits, mark them for edits (wherein the rebase will stop at that commit and let you <code class="language-plaintext highlighter-rouge">git commit
--amend</code> changes into it), and even “squash” commits which lets you mark a commit to be absorbed
into the previous one. This is rather useful for when you’re working on a feature and want to keep
your commits neat, but also want to make fixup patches to older commits. <a href="https://blog.filippo.io/git-fixup-amending-an-older-commit/">Filippo’s <code class="language-plaintext highlighter-rouge">git fixup</code> alias</a>
packages this particular task into a single git command. Changing <code class="language-plaintext highlighter-rouge">EDITOR=true</code> into
<code class="language-plaintext highlighter-rouge">EDITOR=: GIT_SEQUENCE_EDITOR=:</code> will make it not even open the editor for confirmation
and try to do the whole thing automatically.</p>

<p><code class="language-plaintext highlighter-rouge">git rebase -x some_command</code> is also pretty neat, lets you run a shell command on each step during a rebase.</p>

<p>In this model, you are fundamentally thinking of commits as diffs. When you move around
commits in the interactive rebase editor, you’re moving around diffs. When you mark things
for squashing, you’re basically merging diffs. The whole process is about taking a set of
diffs and applying them to a different “base commit”.</p>

<p><img class="center" src="/images/post/memes/diffs-everywhere.jpg" width="400" /></p>

<h2 id="how-do-i-rewrite-history-with-git-filter-branch">How do I rewrite history with <code class="language-plaintext highlighter-rouge">git filter-branch</code>?</h2>

<p><code class="language-plaintext highlighter-rouge">filter-branch</code> does <em>not</em> work with diffs. You’re working with the “snapshot” model
of commits here, where each commit is a snapshot of the tree, and rewriting these commits.</p>

<p>What <code class="language-plaintext highlighter-rouge">git filter-branch</code> will do is for each commit in the specified branch, apply filters to the
snapshot, and create a new commit. The new commit’s parent will be the filtered version of the old
commit’s parent. So it creates a parallel commit DAG.</p>

<p>Because the filters apply on the snapshots instead of the diffs, there’s no chance for this to cause
conflicts like in git rebase. In git rebase, if I have one commit that makes changes to a file, and
I change the previous commit to just remove the area of the file that was changed, I’d have a conflict
and git would ask me to figure out how the changes are supposed to be applied.</p>

<p>In git-filter-branch, if I do this, it will just power through. Unless you explicitly write
your filters to refer to previous commits, the new commit is created in isolation, so it doesn’t
worry about changes to the previous commits. If you had indeed edited the previous commit,
the new commit will appear to undo those changes and apply its own on top of that.</p>

<p><code class="language-plaintext highlighter-rouge">filter-branch</code> is generally for operations you want to apply pervasively to a repository. If
you just want to tweak a few commits, it won’t work, since future commits will appear to undo
your changes. <code class="language-plaintext highlighter-rouge">git rebase</code> is for when you want to tweak a few commits.</p>

<p>So, how do you use it?</p>

<p>The basic syntax is <code class="language-plaintext highlighter-rouge">git filter-branch &lt;filters&gt; branch_name</code>. You can use <code class="language-plaintext highlighter-rouge">HEAD</code> or <code class="language-plaintext highlighter-rouge">@</code>
to refer to the current branch instead of explicitly typing <code class="language-plaintext highlighter-rouge">branch_name</code>.</p>

<p>A very simple and useful filter is the subdirectory filter. It makes a given subdirectory
the repository root. You use it via <code class="language-plaintext highlighter-rouge">git filter-branch --subdirectory-filter name_of_subdir @</code>.
This is useful for extracting the history of a folder into its own repository.</p>

<p>Another useful filter is the tree filter, you can use it to do things like moving around, creating,
or removing files. For example, if you want to move <code class="language-plaintext highlighter-rouge">README.md</code> to <code class="language-plaintext highlighter-rouge">README</code> in the entire history,
you’d do something like <code class="language-plaintext highlighter-rouge">git filter-branch --tree-filter 'mv README.md README' @</code> (you can also
achieve this much faster with some manual work and <code class="language-plaintext highlighter-rouge">rebase</code>). The tree filter will work by checking
out each commit (in a separate temporary folder), running your filter on the working directory,
adding any changes to the index (no need to <code class="language-plaintext highlighter-rouge">git add</code> yourself), and committing the new index.</p>

<p>The <code class="language-plaintext highlighter-rouge">--prune-empty</code> argument is useful here, as it removes commits which are now empty due to the
rewrite.</p>

<p>Because it is checking out each commit, this filter is quite slow. When I initially was trying to
do Steve’s task on the rust repo, I wrote a long tree filter and it was taking forever.</p>

<p>The faster version is the index filter. However, this is a bit trickier to work with (which is why I
tend to use a tree filter if I can get away with it). What this does is operate on the index,
directly.</p>

<p>The “index” is basically where things go when you <code class="language-plaintext highlighter-rouge">git add</code> them. Running <code class="language-plaintext highlighter-rouge">git add</code> will create
temporary objects for the added file, and modify the WIP index (directory tree) to include a
reference to the new file or change an existing file reference to the new one. When you commit, this
index is packaged up into a commit and stored as an object. (More on how these objects work in a
later section)</p>

<p>Now, since this deals with files that are already stored as objects, git doesn’t need to unwrap
these objects and create a working directory to operate on them. So, with <code class="language-plaintext highlighter-rouge">--index-filter</code>, you
can operate on these in a much faster way. However, since you don’t have a working directory,
stuff like adding and moving files can be trickier. You often have to use <code class="language-plaintext highlighter-rouge">git update-index</code>
to make this work.</p>

<p>However, a useful index filter is one which just scrubs a file (or files) from history:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git filter-branch <span class="nt">--index-filter</span> <span class="s1">'git rm --cached --ignore-unmatch filename'</span> HEAD
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">--ignore-unmatch</code> makes the command still succeed if the file doesn’t exist. <code class="language-plaintext highlighter-rouge">filter-branch</code>
will fail if one of the filters fails. In general I tend to write fallible filters like
<code class="language-plaintext highlighter-rouge">command1 1&gt;&amp;2 2&gt;/dev/null ; command2 1&gt;&amp;2 2&gt;/dev/null ; true</code>, which makes it always succeed
and also ignores any stdout/stderr output (which tends to make the progress screen fill up fast).</p>

<p>The <code class="language-plaintext highlighter-rouge">--cached</code> argument on <code class="language-plaintext highlighter-rouge">git rm</code> makes it operate only on the index, not the working directory.
This is great, because we don’t <em>have</em> a working directory right now.</p>

<p>I rarely use <code class="language-plaintext highlighter-rouge">git update-index</code> so I’m not really going to try and explain how it can be used here.
But if you need to do more complex operations in an index filter, that’s the way to go.</p>

<p>There are many other filters, like <code class="language-plaintext highlighter-rouge">--commit-filter</code> (lets you discard a commit entirely),
<code class="language-plaintext highlighter-rouge">--msg-filter</code> (rewriting commit messages), and <code class="language-plaintext highlighter-rouge">--env-filter</code> (changing things like author metadata
or other env vars). You can see a complete list with examples <a href="https://git-scm.com/docs/git-filter-branch">in the docs</a></p>

<h2 id="how-did-i-perform-the-rewrites-on-the-reference-and-nomicon">How did I perform the rewrites on the reference and nomicon?</h2>

<p>For the Rust Reference, basically I had to extract the history of <code class="language-plaintext highlighter-rouge">src/doc/reference.md</code>,
AND <code class="language-plaintext highlighter-rouge">src/doc/reference/*</code> (<code class="language-plaintext highlighter-rouge">reference.md</code> was split up into <code class="language-plaintext highlighter-rouge">reference/*.md</code> recently) into
its own commit. This is an easy tree filter to write, but tree filters take forever.</p>

<p>Instead of trying my luck with an index filter, I decided to just make it so that the
tree filter would be faster. I first extracted <code class="language-plaintext highlighter-rouge">src/doc/</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git filter-branch <span class="nt">-f</span> <span class="nt">--prune-empty</span> <span class="nt">--subdirectory-filter</span> src/doc @
</code></pre></div></div>

<p>Now I had a branch that contained only the history of <code class="language-plaintext highlighter-rouge">src/doc</code>, with the root directory moved to
<code class="language-plaintext highlighter-rouge">doc</code>. This is a much smaller repo than the entirety of Rust.</p>

<p>Now, I moved <code class="language-plaintext highlighter-rouge">reference.md</code> into <code class="language-plaintext highlighter-rouge">reference/</code>:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git filter-branch <span class="nt">-f</span> <span class="nt">--prune-empty</span> <span class="nt">--tree-filter</span> <span class="s1">'mkdir -p reference; mv reference.md reference 1&gt;/dev/null 2&gt;/dev/null; true'</span> @
</code></pre></div></div>

<p>As mentioned before, the <code class="language-plaintext highlighter-rouge">/dev/null</code> and <code class="language-plaintext highlighter-rouge">true</code> bits are because the mv command will fail in some cases
(when reference.md doesn’t exist), and I want it to just continue without complaining when that happens.
I only care about moving instances of that file, if that file doesn’t exist there it’s still okay.</p>

<p>Now, everything I cared about was within <code class="language-plaintext highlighter-rouge">reference</code>. The next step was simple:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git filter-branch <span class="nt">-f</span> <span class="nt">--prune-empty</span> <span class="nt">--subdirectory-filter</span> reference @
</code></pre></div></div>

<p>The whole process took maybe 10 minutes to run, most of the time being spent by the second command.
The final result can be found <a href="https://github.com/rust-lang-nursery/reference">here</a>.</p>

<p>For the nomicon, the task was easier. In the case of the nomicon, it has always resided in
<code class="language-plaintext highlighter-rouge">src/doc/nomicon</code>, <code class="language-plaintext highlighter-rouge">src/doc/tarpl</code>, or at the root. This last bit is interesting, when
<a href="http://twitter.com/Gankra_">Alexis</a> was working on the nomicon, she started off by hacking on it in a separate repo, but
then within that repo moved it to <code class="language-plaintext highlighter-rouge">src/doc/tarpl</code>, and performed a merge commit with rustc. There’s
no inherent restriction in Git that all merges must have a common ancestor, and you can do stuff
like this. I was <a href="https://twitter.com/ManishEarth/status/837441118753062912">quite surprised</a> when I saw this, since it’s pretty uncommon in general,
but really, many projects of that size will have stuff like this. Servo and html5ever do too, and usually
it’s when a large project is merged into it after being developed on the side.</p>

<p>This sounds complicated to work with, but it wasn’t that hard. I took the same subdirectory-filtere’d
doc directory branch used for the reference. Then, I renamed <code class="language-plaintext highlighter-rouge">tarpl/</code> to <code class="language-plaintext highlighter-rouge">nomicon/</code> via a tree filter,
and ran another subdirectory filter:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git filter-branch <span class="nt">-f</span> <span class="nt">--prune-empty</span> <span class="nt">--tree-filter</span> <span class="s1">'mv tarpl nomicon 1&gt;/dev/null 2&gt;/dev/null; true'</span> @
<span class="nv">$ </span>git filter-branch <span class="nt">-f</span> <span class="nt">--prune-empty</span> <span class="nt">--subdirectory-filter</span> nomicon @
</code></pre></div></div>

<p>Now, I had the whole history of the nomicon in the root dir. Except for the commits made by Alexis
before her frankenmerge, because these got removed in the first subdirectory filter (the commits
were operating outside of <code class="language-plaintext highlighter-rouge">src/doc</code>, even though their contents eventually got moved there).</p>

<p>But, at this stage, I already had a branch with the nomicon at the root. Alexis’ original commits
were also operating on the root directory. I can just rebase here, and the diffs of my commits will
cleanly apply!</p>

<p>I found the commit (<a href="https://github.com/rust-lang/rust/commit/a54e64b3c41103c4f6ab840d8ddd3a56ec6b5da8"><code class="language-plaintext highlighter-rouge">a54e64</code></a>) where everything was moved to <code class="language-plaintext highlighter-rouge">tarpl/</code>, and took its parent
(<a href="https://github.com/rust-lang/rust/commit/c7919f2d9835578321bf7556ad1a01fa42e8a7e8"><code class="language-plaintext highlighter-rouge">c7919f</code></a>). Then, I just ran <code class="language-plaintext highlighter-rouge">git rebase --root c7919f</code>, and everything cleanly rebased.
As expected, because I had a history going back to the first child of <a href="https://github.com/rust-lang/rust/commit/a54e64b3c41103c4f6ab840d8ddd3a56ec6b5da8"><code class="language-plaintext highlighter-rouge">a54e64</code></a> with files
moved, and <a href="https://github.com/rust-lang/rust/commit/a54e64b3c41103c4f6ab840d8ddd3a56ec6b5da8"><code class="language-plaintext highlighter-rouge">a54e64</code></a> itself only moved files, so the diffs should cleanly apply.</p>

<p>The final result can be found <a href="https://github.com/rust-lang-nursery/nomicon">here</a>.</p>

<h2 id="appendix-how-are-commits-actually-stored">Appendix: How are commits actually stored?</h2>

<p>The way the actual implementation of a commit works is that each file being stored is hashed and
stored in a compressed format, indexed by the hash. A directory (“tree”) will be a list of hashes, one for
each file/directory inside it, alongside the filenames and other metadata. This list will be hashed
and used everywhere else to refer to the directory.</p>

<p>A commit will reference the “tree” object for the root directory via its hash.</p>

<p>Now, if you make a commit changing some files, most of the files will be unchanged. So will most of
the directories. So the commits can share the objects for the unchanged files/directories, reducing
their size. This is basically a copy-on-write model. Furthermore, there’s a second optimization
called a “packfile”, wherein instead of storing a file git will store a delta (a diff) and a
reference to the file the diff must be applied to.</p>

<p>We can see this at work using <code class="language-plaintext highlighter-rouge">git cat-file</code>. <code class="language-plaintext highlighter-rouge">cat-file</code> lets you view objects in
the “git filesystem”, which is basically a bunch of hash-indexed objects stored in
<code class="language-plaintext highlighter-rouge">.git/objects</code>. You can view them directly by traversing that directory (they’re
organized as a trie), but <code class="language-plaintext highlighter-rouge">cat-file -p</code> will let you pretty-print their contents
since they’re stored in a binary format.</p>

<p>I’m working with <a href="https://github.com/rust-lang/book">the repo for the Rust Book</a>,
playing with commit <a href="4822f2baa69c849e4fa3b85204f219a16bde2f42"><code class="language-plaintext highlighter-rouge">4822f2</code></a>. It’s a commit that changes
just one file (<code class="language-plaintext highlighter-rouge">second-edition/src/ch15-01-box.md </code>), perfect.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git show 4822f2baa69c849e4fa3b85204f219a16bde2f42
commit 4822f2baa69c849e4fa3b85204f219a16bde2f42
Author: Jake Goulding &lt;...&gt;
Date:   Fri Mar 3 14:07:24 2017 <span class="nt">-0500</span>

    Reorder sentence about a generic cons list.

diff <span class="nt">--git</span> a/second-edition/src/ch15-01-box.md b/second-edition/src/ch15-01-box.md
index 14c5533..29d8793 100644
<span class="nt">---</span> a/second-edition/src/ch15-01-box.md
+++ b/second-edition/src/ch15-01-box.md
<span class="o">(</span>diff omitted<span class="o">)</span>

<span class="nv">$ </span>git cat-file <span class="nt">-p</span> 4822f2baa69c849e4fa3b85204f219a16bde2f42

tree ec7cd2821d4bcbafe08f3eca6ea60487bfdc1b52
parent 24cd100e061bb11c3f7f3219467d6d644c50d811
author Jake Goulding &lt;...&gt; 1488568044 <span class="nt">-0500</span>
committer GitHub &lt;noreply@github.com&gt; 1488568044 <span class="nt">-0500</span>

Reorder sentence about a generic cons list.
</code></pre></div></div>

<p>This tells us that the commit is a thing with some author information, a pointer to
a parent, a commit message, and a “tree”. What’s this tree?</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git cat-file <span class="nt">-p</span> ec7cd2821d4bcbafe08f3eca6ea60487bfdc1b52
100644 blob 4cab1f4d267628ab5f4f7c14b1b64a9d4b032409    .gitattributes
040000 tree e1dcc1c754d72450b03542b2106fcb67c78805ff    .github
100644 blob 4c699f440ac134c577cb6f67b04ec5b93c652440    .gitignore
100644 blob e86d887d84a839417c960faf877c9057a8dc6823    .travis.yml
100644 blob 7990f2738876fc0fbc2ca30f5f91e91745b0b8eb    README.md
040000 tree 17b33cb52a5abb67ff678a03e7ed88cf9f163c69    ci
040000 tree 0ffd2c1238345c1b0e99af6c1c618eee4a0bab58    first-edition
100644 blob 5d1d2bb79e1521b28dd1b8ff67f9b04f38d83620    index.md
040000 tree b7160f7d05d5b5bfe28bad029b1b490e310cff22    redirects
040000 tree d5672dd9ef15adcd1527813df757847d745e299a    second-edition
</code></pre></div></div>

<p>This is just a directory! You can see that each entry has a hash. We can use
<code class="language-plaintext highlighter-rouge">git cat-file -p</code> to view each one. Looking at a <code class="language-plaintext highlighter-rouge">tree</code> object will just give
us a subdirectory, but the <code class="language-plaintext highlighter-rouge">blob</code>s will show us actual files!</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git cat-file <span class="nt">-p</span> 7990f2738876fc0fbc2ca30f5f91e91745b0b8eb <span class="c"># Show README</span>
<span class="c"># The Rust Programming Language</span>

<span class="o">[![</span>Build Status]<span class="o">(</span>https://travis-ci.org/rust-lang/book.svg?branch<span class="o">=</span>master<span class="o">)](</span>https://travis-ci.org/rust-lang/book<span class="o">)</span>

To <span class="nb">read </span>this book online, visit <span class="o">[</span>rust-lang.github.io/book/][html].

<span class="o">(</span>rest of file omitted<span class="o">)</span>
</code></pre></div></div>

<p>So how does this share objects? Let’s look at the previous commit:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git cat-file <span class="nt">-p</span> 4822f2baa69c849e4fa3b85204f219a16bde2f42^ <span class="c"># `^` means "parent"</span>
tree d219be3c5010f64960ddb609a849fc42a01ad31b
parent 21c063868f9d7fb0fa488b6f1124262f055d275b
author steveklabnik &lt;...&gt; 1488567224 <span class="nt">-0500</span>
committer steveklabnik &lt;...&gt; 1488567239 <span class="nt">-0500</span>

mdbook needs to be on the PATH <span class="k">for </span>deploy

<span class="nv">$ </span>git cat-file <span class="nt">-p</span> d219be3c5010f64960ddb609a849fc42a01ad31b <span class="c"># the tree</span>
100644 blob 4cab1f4d267628ab5f4f7c14b1b64a9d4b032409    .gitattributes
040000 tree e1dcc1c754d72450b03542b2106fcb67c78805ff    .github
100644 blob 4c699f440ac134c577cb6f67b04ec5b93c652440    .gitignore
100644 blob e86d887d84a839417c960faf877c9057a8dc6823    .travis.yml
100644 blob 7990f2738876fc0fbc2ca30f5f91e91745b0b8eb    README.md
040000 tree 17b33cb52a5abb67ff678a03e7ed88cf9f163c69    ci
040000 tree 0ffd2c1238345c1b0e99af6c1c618eee4a0bab58    first-edition
100644 blob 5d1d2bb79e1521b28dd1b8ff67f9b04f38d83620    index.md
040000 tree b7160f7d05d5b5bfe28bad029b1b490e310cff22    redirects
040000 tree d48b2e06970cf3a6ae65655c340922ae69723989    second-edition
</code></pre></div></div>

<p>If you look closely, all of these hashes are the same, <em>except</em> for the hash for <code class="language-plaintext highlighter-rouge">second-edition</code>.
For the hashes which are the same, these objects are being shared across commits. The differing hash
is <code class="language-plaintext highlighter-rouge">d5672d</code> in the newer commit, and <code class="language-plaintext highlighter-rouge">d48b2e</code> in the older one.</p>

<p>Let’s look at the objects:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git cat-file <span class="nt">-p</span> d5672d
100644 blob 82dc67a6b08f0eb62420e4da3b3aa9c0dc10911a    CONTRIBUTING.md
100644 blob 5cd51aa43f05416996c4ef055df5d6eb58fbe737    Cargo.lock
100644 blob 7ab2575fa5bf4abf6eaf767c72347580c9f769dd    Cargo.toml
100644 blob 96e9f0458b55a4047927de5bf04ceda89d772b2b    LICENSE-APACHE
100644 blob 5a56e6e8ed1909b4e4800aa8d2a0e7033ab4babe    LICENSE-MIT
100644 blob be1135fc6d28eca53959c7fc9ae191523e4bc96f    book.json
100644 blob 1400454f36840e916a7d7028d987c42fcb31b4db    dictionary.txt
100644 blob 5103c84d034d6e8a0e4b6090453ad2cdcde21537    doc-to-md.sh
040000 tree 6715d1d4c97e3d17a088922f687b8d9ffacb5953    dot
100644 blob f9e045c4c1824520534270a2643ebe68311503b8    nostarch.sh
040000 tree f8d9a9452b4bbaeba256b95d40b303cd5fb20a64    nostarch
100644 blob 0a2d16852c11355ef9d8758a304b812633dcf03c    spellcheck.sh
040000 tree 3f8db396566716299330cdd5f569fb0a0c4615dd    src
100644 blob 56677811f451084de7c3a2478587a09486209b14    style-guide.md
040000 tree 7601821a2ff38906332082671ea23e4074464dd2    tools

<span class="nv">$ </span>git cat-file <span class="nt">-p</span> d48b2e
100644 blob 82dc67a6b08f0eb62420e4da3b3aa9c0dc10911a    CONTRIBUTING.md
100644 blob 5cd51aa43f05416996c4ef055df5d6eb58fbe737    Cargo.lock
100644 blob 7ab2575fa5bf4abf6eaf767c72347580c9f769dd    Cargo.toml
100644 blob 96e9f0458b55a4047927de5bf04ceda89d772b2b    LICENSE-APACHE
100644 blob 5a56e6e8ed1909b4e4800aa8d2a0e7033ab4babe    LICENSE-MIT
100644 blob be1135fc6d28eca53959c7fc9ae191523e4bc96f    book.json
100644 blob 1400454f36840e916a7d7028d987c42fcb31b4db    dictionary.txt
100644 blob 5103c84d034d6e8a0e4b6090453ad2cdcde21537    doc-to-md.sh
040000 tree 6715d1d4c97e3d17a088922f687b8d9ffacb5953    dot
100644 blob f9e045c4c1824520534270a2643ebe68311503b8    nostarch.sh
040000 tree f8d9a9452b4bbaeba256b95d40b303cd5fb20a64    nostarch
100644 blob 0a2d16852c11355ef9d8758a304b812633dcf03c    spellcheck.sh
040000 tree f9fc05a6ff78b8211f4df931ed5e32c937aba66c    src
100644 blob 56677811f451084de7c3a2478587a09486209b14    style-guide.md
040000 tree 7601821a2ff38906332082671ea23e4074464dd2    tools
</code></pre></div></div>

<p>Again, these are the same, except for that of <code class="language-plaintext highlighter-rouge">src</code>. <code class="language-plaintext highlighter-rouge">src</code> has a <em>lot</em> of files in it,
which will clutter this post, so I’ll run a diff on the outputs of <code class="language-plaintext highlighter-rouge">cat-file</code>:</p>

<div class="language-udiff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> diff -U5 &lt;(g cat-file -p f9fc05a6ff78b8211f4df931ed5e32c937aba66c) &lt;(g cat-file -p 3f8db396566716299330cdd5f569fb0a0c4615dd)
<span class="gd">--- /dev/fd/63  2017-03-05 11:58:22.000000000 -0800
</span><span class="gi">+++ /dev/fd/62  2017-03-05 11:58:22.000000000 -0800
</span><span class="p">@@ -63,11 +63,11 @@</span>
 100644 blob ff6b8f8cd44f624e1239c47edda59560cdf491ae   ch14-02-publishing-to-crates-io.md
 100644 blob c53ef854a74b6c9fbd915be1bf824c6e78439c42   ch14-03-cargo-workspaces.md
 100644 blob 3fb59f9cc85b6b81994e83a34d542871a260a8f0   ch14-04-installing-binaries.md
 100644 blob e1cd1ca779fdf202af433108a8af6eda317f2717   ch14-05-extending-cargo.md
 100644 blob 3173cc508484cc447ebe42a024eac7d9e6c2ddcd   ch15-00-smart-pointers.md
<span class="gd">-100644 blob 14c5533bb3b604c6e6274db278d1e7129f78d55d   ch15-01-box.md
</span><span class="gi">+100644 blob 29d87933d6832374b87d98aa5588e09e0c1a4991   ch15-01-box.md
</span> 100644 blob 47b35ed489d63ce6a885289fec01b7b16ba1afea   ch15-02-deref.md
 100644 blob 2d20c55cc8605c0c899bc4867adc6b6ea1f5c902   ch15-03-drop.md
 100644 blob 8e3fcf4e83fe1ce985a7c0b479b8b16701765aaf   ch15-04-rc.md
 100644 blob a4ade4ae8bf5296d79ed51d69506e71a83f9f489   ch15-05-interior-mutability.md
 100644 blob 3a4db5616c4f5baeb95d04ea40c6747e60181684   ch15-06-reference-cycles.md
</code></pre></div></div>

<p>As you can see, only the file that was changed in the commit has a new blob stored.
If you view <code class="language-plaintext highlighter-rouge">14c553</code> and <code class="language-plaintext highlighter-rouge">29d879</code> you’ll get the pre- and post- commit versions
of the file respectively.</p>

<p>So basically, each commit stores a tree of references to objects, often sharing nodes
with other commits.</p>

<p>I haven’t had the opportunity to work with packfiles much, but they’re an
additional optimization on top of this. <a href="https://codewords.recurse.com/issues/three/unpacking-git-packfiles">Aditya’s post</a> is a good
intro to these.</p>

</div>


  <footer>
    <p class="meta">
      
<span class="byline author vcard beforesep">Posted by <span class="fn">Manish Goregaokar</span></span>

      





      



<span class="categories aftersep">
  
    <a class='category' href='/blog/categories/programming/'>programming</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://manishearth.github.io/blog/2017/03/05/understanding-git-filter-branch/" data-via="Manishearth" data-counturl="http://manishearth.github.io/blog/2017/03/05/understanding-git-filter-branch/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2017/03/04/what-are-sum-product-and-pi-types/" title="Previous Post: What are sum, product, and pi types?">&laquo; What are sum, product, and pi types?</a>
      
      
        <a class="basic-alignment right" href="/blog/2017/03/11/why-quantum-computing-is-weird/" title="Next Post: Why quantum computing is weird">Why quantum computing is weird &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
<h1> About Me </h1>
<div id="about">
    I'm a self-taught programmer with interests in programming languages, online communities, human languages, Rust, and physics, to name a few. <br><br>

    I'm currently on the Rust core team, and I work at Google on <a href="https://github.com/unicode-org/icu4x">ICU4X</a>.
</div>
<div id="doodads">
 <a href="http://twitter.com/Manishearth" style="white-space:normal">   <img style="border:none;box-shadow:none" src="/images/twitter.png" width="30px"></a>
 <a href="http://github.com/Manishearth" style="white-space:normal">   <img style="border:none;box-shadow:none"  src="/images/github.png" width="30px"></a>
</div>
</section>
<section>
<!-- <iframe scrolling="no" style="border: 0; height: 58px; width: 208px; overflow: hidden;" src="https://se-flair.appspot.com/751483b5-3bd0-467a-b3aa-f0bb8ac3887d/"></iframe> -->
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2021/03/15/arenas-in-rust/">Arenas in Rust</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/02/22/integrating-rust-and-c-plus-plus-in-firefox/">Integrating Rust and C++ in Firefox</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/10/09/on-voting-systems/">On Voting Systems</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/02/04/rust-governance-scaling-empathy/">Rust Governance: Scaling Empathy</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/09/11/converting-a-webgl-application-to-webvr/">Converting a WebGL Application to WebVR</a>
      </li>
    
  </ul>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2021 - Manish Goregaokar - Licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY SA 4.0</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
